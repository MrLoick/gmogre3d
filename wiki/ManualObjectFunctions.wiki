#summary Provides a simplified interface to generating manual objects with custom geometry.

=== Overview ===
These functions give you a simple interface specifically for the purpose of building a 3D object simply and quickly. Note that if you intend to instance your object you will still need to become familiar with the Mesh class. 

These functions draw heavily on the interface for OpenGL immediate-mode (glBegin, glVertex, glNormal etc), since this is generally well-liked by people. There are a couple of differences in the results though - internally this class still builds hardware buffers which can be re-used, so you can render the resulting object multiple times without re-issuing all the same commands again. Secondly, the rendering is not immediate, it is still queued just like all GMOgre objects. This makes this object more efficient than the equivalent GL immediate-mode commands, so it's feasible to use it for large objects if you really want to. 

To construct some geometry with this object:
   # If you know roughly how many vertices (and indices, if you use them) you're going to submit, call !EstimateManualObjectVertexCount and !EstimateManualObjectIndexCount. This is not essential but will make the process more efficient by saving memory reallocations.
   # Call !BeginManualObjectSection() to begin entering data
   # For each vertex, call !ManualObjectPosition(), !ManualObjectNormal(), !ManualObjectTextureCoordX(), !ManualObjectColor() to define your vertex data. Note that each time you call !ManualObjectPosition() you start a new vertex. Note that the first vertex defines the components of the vertex - you can't add more after that. For example if you didn't call !ManualObjectNormal() in the first vertex, you cannot call it in any others. You ought to call the same combination of methods per vertex.
   # If you want to define triangles (or lines/points) by indexing into the vertex list, you can call !ManualObjectIndex() as many times as you need to define them. If you don't do this, the class will assume you want triangles drawn directly as defined by the vertex list, i.e. non-indexed geometry. Note that stencil shadows are only supported on indexed geometry, and that indexed geometry is a little faster; so you should try to use it.
   # Call !EndManualObjectSection() to finish entering data.
   # Optionally repeat the begin-end cycle if you want more geometry using different rendering operation types, or different materials After calling end(), the class will organize the data for that section internally and make it ready to render with. You should attach the object to a !SceneNode to make it visible. Other aspects like the relative render order can be controlled using standard functions like !SetManualObjectRenderQueueGroup. 

You can also use !BeginUpdateManualObjectSection() to alter the geometry later on if you wish. If you do this, you should call !EnableManualObjectDynamic(true) before your first call to !BeginManualObjectSection(), and also consider using !EstimateManualObjectVertexCount / !EstimateManualObjectIndexCount if your geometry is going to be growing, to avoid buffer recreation during growth. 

Note that like all GMOgre geometry, triangles should be specified in anti-clockwise winding order (whether you're doing it with just vertices, or using indexes too). That is to say that the front of the face is the one where the vertices are listed in anti-clockwise order. 
<BR>
<BR>
=== !CreateManualObject() ===
----
Create a manual object, an object which you populate with geometry manually through a GL immediate-mode style interface.
<BR>
<BR>
<BR>
=== !DestroyManualObject(real manual_obj_id) ===
----
Removes a manual object from the current !SceneManager and destroys it.
====Parameters====
   * _manual_obj_id_ - The ID of the manual object.
<BR>
<BR>
=== !SetManualObjectRenderQueueGroup(real manual_obj_id, real type) ===
----
Sets the render queue group this entity will be rendered through.

Render queues are grouped to allow you to more tightly control the ordering of rendered objects. If you do not call this method, all Entity objects default to the default queue, which is fine for most objects. You may want to alter this if you want this entity to always appear in front of other objects, e.g. for a 3D menu system or such. 

See !RenderQueue for more details.
====Parameters====
   * _manual_obj_id_ - The ID of the manual object.
   * _type_ - The render queue ID.
<BR>
<BR>
=== !EnableManualObjectIdentityProjection(real manual_obj_id, real enable) ===
----
Enables or disables the 'identity' projection.

Usually manual objects will use a projection matrix as determined by the active camera. However, if they want they can cancel this out and use an identity projection, which effectively projects in 2D using a {-1, 1} view space. Useful for overlay rendering. Normally you don't need to change this. The default is false.
====Parameters====
   * _manual_obj_id_ - The ID of the manual object.
   * _enable_ - Whether to enable or disable identity projection.
<BR>
<BR>
=== !EnableManualObjectIdentityView(real manual_obj_id, real enable) ===
----
Sets whether or not to use an 'identity' view.

Usually manual objects will use a view matrix as determined by the active camera. However, if they want they can cancel this out and use an identity matrix, which means all geometry is assumed to be relative to camera space already. Useful for overlay rendering. Normally you don't need to change this. The default is false.
====Parameters====
   * _manual_obj_id_ - The ID of the manual object.
   * _enable_ - Whether to enable or disable identity view.
<BR>
<BR>
=== !SetManualObjectBoundingBox(real manual_obj_id, real mx, real mz, real my, real Mx, real Mz, real My) ===
----
Sets the bounding box.

Call this after having finished creating sections to modify the bounding box. E.g. if you're using manual object to create 2D overlays you can call things function to set an infinite bounding box so that the object always stays visible when attached.

To set an infinite bounding box specify -1 for all parameters.
====Parameters====
   * _manual_obj_id_ - The ID of the manual object.
   * _mx_, _mz_, _my_ - The minimum corner.
   * _Mx_, _Mz_, _My_ - The maximum corner.
<BR>
<BR>
=== !EnableManualObjectDynamic(real manual_obj_id, real enable) ===
----
Use before defining geometry to indicate that you intend to update the geometry regularly and want the internal structure to reflect that.
====Parameters====
   * _manual_obj_id_ - The ID of the manual object.
   * _enable_ - Whether to enable or disable dynamic updating.
<BR>
<BR>
=== !EstimateManualObjectVertexCount(real manual_obj_id, real size) ===
----
Estimate the number of vertices ahead of time.

Calling this helps to avoid memory reallocation when you define vertices. Also very handy when using !BeginUpdateManualObject() to manage dynamic data - you can make the vertex buffers a little larger than their initial needs to allow for growth later with this method. 
====Parameters====
   * _manual_obj_id_ - The ID of the manual object.
   * _size_ - The estimated number of vertices.
<BR>
<BR>
=== !EstimateManualObjectIndexCount(real manual_obj_id, real size) ===
----
Estimate the number of indices ahead of time.

Calling this helps to avoid memory reallocation when you define indices. Also very handy when using !BeginUpdateManualObject() to manage dynamic data - you can make the index buffers a little larger than their initial needs to allow for growth later with this method. 
====Parameters====
   * _manual_obj_id_ - The ID of the manual object.
   * _size_ - The estimated number of indices.
<BR>
<BR>
=== !BeginUpdateManualObjectSection(real manual_obj_id, string mat_name, real type) ===
----
=== !BeginManualObjectSection(real manual_obj_id, string mat_name, real type) ===
----
=== !ManualObjectPosition(real manual_obj_id, real x, real z, real y) ===
----
=== !ManualObjectNormal(real manual_obj_id, real x, real z, real y) ===
----
=== !ManualObjectTriangle(real manual_obj_id, real i1, real i2, real i3) ===
----
=== !ManualObjectQuad(real manual_obj_id, real i1, real i2, real i3, real i4) ===
----
=== !ManualObjectTextureCoord1(real manual_obj_id, real u) ===
----
=== !ManualObjectTextureCoord2(real manual_obj_id, real u, real v) ===
----
=== !ManualObjectTextureCoord3(real manual_obj_id, real u, real v, real w) ===
----
=== !ManualObjectTextureCoord4(real manual_obj_id, real x, real z, real y, real w) ===
----
=== !AddManualObjectColor(real manual_obj_id, real color, real alpha) ===
----
=== !ManualObjectIndex(real manual_obj_id, real index) ===
----
=== !EndManualObjectSection(real manual_obj_id) ===
----
=== !EndUpdateManualObjectSection(real manual_obj_id) ===
----
=== !ClearManualObject(real manual_obj_id) ===
----
=== !SetManualObjectMaterial(real manual_obj_id, real index, string mat_name) ===
----
=== !ConvertManualObjectToMesh(real manual_obj_id, string name, string group) ===
----
=== !SetManualObjectQueryFlags(real manual_obj_id, real flags) ===
----
Sets the query flags for this object.

When performing a scene query, this entity will be included or excluded according to flags on the entity and flags on the query. This is a bitwise value, so only when a bit on these flags is set, will it be included in a query asking for that flag. The meaning of the bits is application-specific.
====Parameters====
   * _manual_obj_id_ - The ID of the manual object.
   * _flags_ - The application specific flags.
<BR>
<BR>